# Дерево проекта
```bash
.
├── app
│   ├── api
│   │   ├── api_kuda_go.py
│   │   └── api_telegram_bot.py
│   ├── app_database
│   │   ├── crud.py
│   │   └── users.db
│   ├── main.py
│   └── Makefile
├── pyproject.toml
├── README.md
├── reports
│   ├── record_001.md
│   ├── record_002.md
│   ├── record_003.md
│   ├── record_004.md
│   └── договорённости по задаче
├── requirements.txt
└── uv.lock

5 directories, 15 files
```
---

# Изменения
- Объединил api модули в одну директорию: `api_telegram` и `api_kuda_go` удалены, создана новая дректория `api`, кода перенесны модули `api_kuda_go.py` и `api_telegram_bot.py`
- Создана директория `app_database`, в которой хранится модуль `crud.py` и база `users.db`
- Добавил файл с зависимостями `requirements.txt`
- Версия проекта обновлена с `0.1.0` -> `1.0.0`
- В `main.py` - добавил настройки планировщика, добавил функцию prepare_message - для подготовки текста сообщения, post_event - для отправки текста сообщения, send_event - использует первые две функции, send_daily_post - функция для планировщика, занимается рассылкой в фоне. В webhook - добавил обработку присылаеымх пользователем сообщений /start, /delete, /event, /help. В index добавил вывод текста от бота - его состояние
---

### main.py
```python
import atexit
import sys

from api.api_kuda_go import collect_data_for_sending
from api.api_telegram_bot import (
    check_bot,
    set_webhook,
    send_image,
    send_message,
)
from app_database.crud import add_id, get_all_id, remove_id
from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.triggers.cron import CronTrigger
from flask import Flask, request
from flask_sslify import SSLify
```
#### Импорты
- `import atexit` - модуль для автоматического завершения планировщика
- `sys` - модуль для роботы с системой, с ПК
- `from api.api_kuda_go import collect_data_for_sending` - из модуля `api_kuda_go` в пакете `api`, имортируем функцию `collect_data_for_sending` для поллучения списка с данными из апи KudaGo
- `from api.api_telegram_bot import` - из модуля `api_telegram_bot` в пакете `api`, импортируем блок функций: `check_bot`, `set_webhook`, `send_image`, `send_message` для отправки картинок с пописью, отправки текста, установки вебхка и провери токена бота.
- `from app_database.crud import add_id, get_all_id, remove_id` - из модуля `crud` в пакете `app_database`, импортируем функции: `add_id`, `get_all_id`, `remove_id`
- `from apscheduler.schedulers.background import BackgroundScheduler` - из библиотеки `apscheduler` импортируем `BackgroundScheduler` для настройки планировщика работы в фоне
- `from apscheduler.triggers.cron import CronTrigger` - из библиотеки `apscheduler` импортируем `CronTrigger` для установки времени в расписании
- `from flask import Flask, request` - из библиотеки `flask` импортируем `Flask` для создания экземпляра веб-приложения, `request` для обработки запросов поступающих в приложение
- `from flask_sslify import SSLify` - импорт `SSLify` для создания безопасного `HTTP` соединения

#### Настройки и функции

```python
app = Flask("__name__")
ssl_certificate = SSLify(app)
scheduler = BackgroundScheduler()
```
- `app = Flask("__name__")` - создание экземпляра веб-приложения, через переменную `app` теперь можно управлять приложением и записывать настройки.
- `ssl_certificate = SSLify(app)` - для создания безопасного http соединения, добавляем эксземпляр `SSLify` приложение `app`
- `scheduler = BackgroundScheduler()` - переменной `scheduler` присваиваем экземпляр планировщика, который будет работать в фоне.

> Другая часть настройки планировщика ниже т.к. python при выполнении инструкции читает код сверху вниз.
> 
> Нужно сначала написать реализацию функции, которую будет использовать планировщик и только потом записывать настройки планировщика и добавить в него нужную нам функцию.
>
---

```python
def prepare_message(event: dict) -> str:
    """Подготовить сообщение.
    В цикле проходит по словарю и записывает данные в строку message
    
    Args:
        event (dict): словарь с данными по событию
    Returns:
        str: готовое сообщение
        Новогодний фестиваль хендмейда и дизайна «Петербургская ярмарка»
        Предпраздничная «Петербургская ярмарка» во 2-м павильоне «Ленфильме» согреет гостей тёплой новогодней атмосферой. Мастера и дизайнеры представят интересные товары ручной работы и в очередной раз докажут, что изделия от местных брендов — это круто.
        Дата проведения: С 2025-12-20 12:00:00 по 2025-12-21 21:00:00
    """
    message = ""
    for key, value in event.items():
        if "image" == key:
            continue
        if len(value) == 0:
            continue
        if "place" == key and "title" in value.keys():
            message += f"{value.get("title")}, {value.get("address")}\n"
            continue
        if "publication_date" == key:
            continue
        if "dates" == key:
            message += f"Дата проведения: {value}\n"
            continue
        message += f"{value}\n"
    return message
```
- `def prepare_message(event: dict) -> str:` - функция подготовки текста сообщения, аргументом принимает словарь в формате как предствлено ниже, возращает готовыую к отправке строку, без фигурных скобок или других не нужэных символов.
```python
{'dates': '',
 'description': 'Новогодние и рождественские дни в Санкт-Петербурге — это '
                'нарядные ёлки, декорации, иллюминация и, конечно же, ярмарка. '
                'В этом году праздничные домики появятся сразу на трёх '
                'площадях и будут работать с 13 декабря по 11 января.',
 'image': 'https://media.kudago.com/images/event/4d/30/4d30ea696ee39c6d3fd922be8d6cc018.jpg',
 'place': {},
 'price': '',
 'publication_date': '2025-10-31 11:33:59',
 'title': 'рождественская ярмарка'}
```

- `message = ""` - объявляем переменную и присваиваем ей пустую строку
- `for key, value in event.items():` - создаём цикл, чтобы пройтись по всем ключам (`dates`, `description` и т.д.). Принято решение идти в цикле, а не создавать шаблон сообщения т.к. количество ключенй в разное, а цикл гарантировано пройдёт по всему что есть в словаре пока не закончатся ключи т.е. ещё и не нужно следить за количеством элементов в словаре. Так же для цикла создаём две переменные `key` и `value`.
    - `key` - перваа в очереди перемееная, в неё будет присвоено значение ключа (`date`, `description` и т.д.).
    - `value` - вторая в очереди переменная, ей будет присвоено значение ключа переменной (`'рождественская ярмарка'` это значение содержится в ключе `title`).
    - `event.items()` - эта форма записи отдаёт в кортеж (ключ, значение), которые будут присваиваться переменным (`'title'`, `'рождественская ярмарка'`) т.к. это кортеж то изъять значение молжно по индексу [0] и [1] т.о. переменная `key` можно воспринять как `key = ('title', 'рождественская ярмарка')[0]` приваивается первое значение по индексу 0, а `value` как `('title', 'рождественская ярмарка')[1]` присваивается второе значение по индексу 1
- `if "image" == key:` - блок ветвления логики елси/иначе если/иначе. Если левая и правая часть условия совпадут т.е. значение переменной `key` будет равным `image` тогда ничего не делать, продолжить цикл - перейти к следующему ключу. Т.к. в сообщении нам не нужен адрес картинки в интернете, этот ключ пропускаем. Для этого используется ключевое слово `continue`
- `if len(value) == 0:` - если длина строки переменной `value` равна нулю, то переходм к следующему ключу.
- `if "place" == key and "title" in value.keys():` - тут у нас два условия. Если значение переменной `key` равно `place` и ключ `title` есть в (`in`) списке ключей переменной `value` т.к. ожидаем словарь (`value.keys()` - получение списка ключенй)
- `message += f"{value.get("title")}, {value.get("address")}\n"` - тогда в переменную `message` приваиваем с добавлением строку с названием места и его адресом. Если убрать форму записи `+=`, то запись будет выглядеть как `message + message + f"{value.get("title")}, {value.get("address")}\n"` т.е. мы обявляем новую переменную с таким же именем `message` и присваиваем ей значение переменной `message` плюс новые данные. `\n` - это управляющая конструкция, которая означает, что строка заканчивается переносом строки.
- `if "publication_date" == key:` - значение переменной будет равно строке `publication_date`, то перейти к следующему ключу. Убрал дату публикации из сообщения т.к. это по итогу выглядело странно и не органично.
- `if "dates" == key:` - если значение переменной `key` будет равно строке `dates`, тогда записать строку `message += f"Дата проведения: {value}\n"`. Добавил это условие т.к. был не ясен контекст просто даты в сообщении.
- `message += f"{value}\n"` - эта строка выполняется всегда в цикле, если конечно цикл не прервался по условиям выше.
- `return message`

Результат:
```text
рождественская ярмарка
Новогодние и рождественские дни в Санкт-Петербурге — это нарядные ёлки, декорации, иллюминация и, конечно же, ярмарка. В этом году праздничные домики появятся сразу на трёх площадях и будут работать с 13 декабря по 11 января.
```
---

```python
def post_event(chat_id: str, message: str, url_image: str=None) -> bool:
    """Отправить пост в телеграм.
    Отправляем сообщение в ТГ. Если есть картинка, отправляем текс с картинкой
    одним сообщением, иначе только текст.

    Args:
        chat_id (str): идентификатор чата
        message (str): подготовленный текст сообщения
        url_message (str): адрес к картинке, по умолчанию None
    Returns:
        bool: если отправка сообщения прошла без ошибок возвращается True
        иначе False
    """
    try:
        if url_image is None:
            send_message(chat_id, message)
        else:
            send_image(chat_id, url_image, message)
        return True
    except Exception as e:
        print(f"Не предвиденная ошибка: {e}")
        return False
```
- `post_event(chat_id: str, message: str, url_image: str=None) -> bool` - функция, которая отпроавляет сообщения в ТГ. Принимает позиционные аргументы `chat_id` - идентификатор чата, `message` - текст сообщения, `url_image` - адрес картинки в интернете, возвращает булево значение (1/0 True/False Правда/Ложь)
- код обёрнут в блок `try/except` для отлова непредвиденных ошибок.
- `if url_image is None:` - если переменная `url_image` равна значению `None` - пустая, то отправить в ТГ только сообщение `send_message(chat_id, message)`, передаём в аргументы уникальный id чата и текст.
- `else:` - иначе отправить сообщение с картинкой `send_image(chat_id, url_image, message)`, передаём в аргументы уникальный id чата, текст и веб адрес картинки
- `return True` - инструкция звершилась успешно, возвращаем `True`
- `except Exception as e:` - перехват непредвиденной ошибки, `Exception` в данном случае перехватывает абсолютно все ошибки
- `print(f"Не предвиденная ошибка: {e}")` - печать в консоль данные об ошибке
- `return False` - инструкция завершилась с ошибкой, возвращаем `False`
---

```python
def send_event_response(chat_id: str) -> bool:
    """Подготоваить и отправить сообщение о событиях

    Args:
        chat_id (str): id чата с пользовтелем
    Returns:
        bool: True если сообщения отправлены, False если нет 
    """
    try:
        event_data = collect_data_for_sending()
        for event in event_data:
            message = prepare_message(event)
            post_event(chat_id, message, event.get("image"))
        return True
    except Exception as e:
        print(f"Ошибка: {e}")
        return False
```
- `send_event_response(chat_id: str) -> bool:` - функция для подготовки и отправки сообщений. Принимает позиционным аргументов идентификатор чата, возвращает `True`/`False`
- Для отлова непредвиденных ошибок, инструкция обёрнута в блок `try/except`
- `event_data = collect_data_for_sending()` - в переменную `event_data` кладём список словарей полученные из апи KudaGo.
- `for event in event_data` - запускаем цикл по списку словарей, словарь помещаем в пеерменную `event`
- `message = prepare_message(event)` - преобразуем данные словаря в текст, для этого передаём в функцию переменную `event`, кторая содержит словарь с данными
- `post_event(chat_id, message, event.get("image"))` - для отправки сообщения используем функцию `post_event`, передаём в неё аргументы идентификатор чата, подготовленный текст и адрес картинки (мы не знаем есть в словаре ключ `image` или нет, поэтому используем метод словаря `get`, если ключ существует мы получим значение, если ключа нет, то получим значение ничего т.е. `None`)
- `return True` - цикл завершился и прошёл по каждому элементу списка, инструкция завершилась успешно и возвращает `True`
- `except Exception as e:` - если возникла ошибка
- `print(f"Ошибка: {e}")` - печатаем в консоль текст ошибки (обычно ошибки не выводятся в консоль, чтобы не потерять их записывают в логи, файлы с расширением `.log` или в любые другие файлы, суть в том что логи всегда под рукой)
- `return False` - инстпукция завершилась с ошибкой, возвращаем `False`
---

```python
def send_daily_post():
    """Подготвить и отправить ежедневное сообщение
    Функция готовит и отправляет сообщения всем чатам,
    которые на ходятся в базе даненых.
    """
    try:
        event_data = collect_data_for_sending()
        chat_ids = get_all_id()
        for event in event_data:
            for chat_id in chat_ids:
                message = prepare_message(event)
                post_event(chat_id, message, event.get("image"))
    except Exception as e:
        print(f"Ошибка при отправке поста: {e}")        
```
- `send_daily_post()` - отдельная функция для отправки ежедневных фоновых постов в ТГ. Без аргументов, всё внутри функции. Без возвращаемых значений.
- Обоварчиваем инструкцию в блок `try/except`
- `event_data = collect_data_for_sending()` - получаем список словарей с данными для постов
- `chat_ids = get_all_id()` - получаем список всех уникальных идентификаторов чатов из базы данных
- `for event in event_data:` - запускаем цикл, в переменную `event` помещаем словарь из списка `event_data`
-  `for chat_id in chat_ids:` - внутри цикла, запускаем вложенный цикл, который пойдёт по списку с идентификаторами чата.
> Логика такая: например в переменной `event_data` пять (5) словарей, а в переменной `chat_ids` десять (10) идентификаторов.
> 
> Берём первый пост из `event_data` и отправляем его по очереди в каждый чатик по идентификатору из `chat_ids`
> 
> Берём второй пост из `event_data` и опять отправляем его по очереди в каждый чатик по идентификатору из `chat_ids`
> 
> Получается что по внешнему циклу `for event in event_data:` мы идём один раз, а по вложенному циклу `for chat_id in chat_ids:` мы проходим 5 раз по 10 элементам
> 
> Итого у нас 50 отправленных сообщений `for event in event_data:`
- `message = prepare_message(event)` - подготовка сообщения
- `post_event(chat_id, message, event.get("image"))` - отправка сообщения
- `except Exception as e:` - ловим ошибку
- `print(f"Ошибка при отправке поста: {e}")` - печатаем в консоль
---

```python
scheduler.add_job(
    func=send_daily_post,
    trigger=CronTrigger(hour=13, minute=12),
    id="daily_post_job",
    name="Ежедневные уведомления по БД",
    replace_existing=True
)


def shutdown_scheduler():
    print("Планировщик останавливается...")
    scheduler.shutdown()
    print("Планировщик остановлен.")


atexit.register(shutdown_scheduler)

scheduler.start()
print("Планировщик запущен при старте приложения.")
```
- `scheduler.add_job` - конфигурируем планировщик, метод `add_job` позволяет добавить в план запись. Метод имеет несколько именованных аргументов.
    - `func=send_daily_post` - указываем какую функцию выполнять
    - `trigger=CronTrigger(hour=13, minute=12)` - указываем тригер, по которому будет запускаться функция, в этом случае по времени, ипользуем метод объекта `CronTrigger`, указываем часы и минуты. Для локального запуска можно указать время актуальное для часового пояса. При работе функции на сервере для московского времни нужно указывать `+3 часа`, например выполнение функции каждый день в `9:00`. На локальном ПК `CronTrigger(hour=9, minute=0)`, на сервере `CronTrigger(hour=12, minute=0)` т.к. время по `UTC` (UTC (Coordinated Universal Time) — это всемирное координированное время, которое не подвержено сезонным изменениям и используется как основной стандарт для определения времени в различных часовых поясах.)
    - `id="daily_post_job"` - присвоение уникального идентификатора записи в планировщике
    - `name="Ежедневные уведомления по БД"` - привоение имени записи
    - `replace_existing=True` - после выполнения и создании новой записи можно перезаписать запись с теми же данными. Грубо говоря переиспользовать запись.
- `atexit.register(shutdown_scheduler)` - регистрация выключения планировщика. Планировщик завершает свои задачи и выключается, сохраняя при этом в календаре задачи. В аргументы принимает функцию `shutdown_scheduler`
- `def shutdown_scheduler():` - короткая функция, чтобы не писать в аргументах `atexit.register` три строчки и для простоты чтения
    - `print("Планировщик останавливается...")` - печать в консоль сообщения
    - `scheduler.shutdown()` - завершение активных процессов планировщика
    - `print("Планировщик остановлен.")` - печать в консоль сообщения
- `scheduler.start()` - запуск планировщика, функция выполнится при запуске приложения
- `print("Планировщик запущен при старте приложения.")` - печать в консоль сообщения
---

```python
@app.route("/", methods=["POST", "GET"])
def index():
    """Главная страница приложения
    Печатет заголовок первого уровня, что бот работает.
    На второй строке техническое сообщение сv данными о боте.
    """
    message = f"<h1>Бот работает</h1>\n{check_bot()}"
    return message
```
- Кроме сообщения, что бот работает, добавил вывод функции `check_bot` для проверки токена
---

```python
@app.route("/webhook", methods=["POST"])
def webhook():
    try:
        update = request.get_json()
        if 'message' in update:
            chat_id_list = get_all_id()
            chat_id = update['message']['chat']['id']
            text = update['message'].get('text', '')
            if text == "/start":
                if chat_id in chat_id_list:
                    send_message(chat_id, "Чат в расписание уже был добавлен")
                else:
                    send_message(
                             chat_id,
                             "Чат добавлен в расписание, события каждый день"
                         )
                    add_id(chat_id)
                    send_message(chat_id, "Подготовка к отправке первых событий")
                    send_event_response(chat_id)                    
            elif text == "/delete":
                removed_chat_id = remove_id(chat_id)
                if removed_chat_id:
                    send_message(chat_id, "Чат из расписания убран, рассылка отменена.")
                else:
                    send_message(chat_id, "Не предвидженная ошибка, попробуй позже")
            elif text == "/event":
                send_message(chat_id, "Собираем данные о событиях, минуту...")
                send_event_response(chat_id)
            elif text == "/help":
                message = """- Команда /start - добавляет чат в расписание для ежедневной отправки сообщений о событиях в городе
- Команда /delete - убирает чат из расписания
- Команда /event - подготавливает данные о событиях и однократно отправляет в чат
- Команда /help - печатает это сообщение
            """
                send_message(chat_id, message)
    except Exception as e:
        print(f"Ошибка: {e}")
    return "Ok"
```
- Инструкция в блоке `try/excrpt` для отлова ошибок
- `update = request.get_json()` - приваиваем полученные данные с сервера ТГ в переменную
- `if 'message' in update` - если ключ `message` есть в словаре `update` будет выполнен следующий код
    - `chat_id_list = get_all_id()` - получаем из базы данных спискок всех id чатов
    - `chat_id = update['message']['chat']['id']` - присвоить переменной id текущего чата
    - `text = update['message'].get('text', '')` - присвоить переменной текст сообщения отправлленного из чата
    - `if text == "/start":` - если содержимое переменной `text` будет равно строке `/start` выполнить следующий код
        - `if chat_id in chat_id_list:` - если id текущего чата есть в базе данных
            - `send_message(chat_id, "Чат в расписание уже был добавлен")` - отправить ответ текстовое сообщение
        - `else:` - иначе выполнить код
            - `send_message(chat_id, "Чат добавлен в расписание, события каждый день")` - отправить текстовое сообщение
            - `add_id(chat_id)` - добавить в базу id чата
            - `send_message(chat_id, "Подготовка к отправке первых событий")` - отправить текстовое сообщение, что плнируеются первые сообщения
            - `send_event_response(chat_id)` - подготовка и отправка сообщений
    - `elif text == "/delete":` - иначе если содержимое переменной `text` равно строке `/delete`
        - `removed_chat_id = remove_id(chat_id)` - присвоить переменной результат выполнения функции `remove_id(chat_id)`  - реузльтат или `True` или `False`
        - `if removed_chat_id:` - если `True` отправляем текстовое сообщение `send_message(chat_id, "Чат из расписания убран, рассылка отменена.")`
        - Иначе отпарвляем текстовое сообщение с сообщение, что удаление не требуется `send_message(chat_id, "Не предвидженная ошибка, попробуй позже")`
    - `elif text == "/event":` - иначе если содержимое переменной `text` равно строке `/event`
        - `send_message(chat_id, "Собираем данные о событиях, минуту...")` - отправить текстовое сообщение, что подгатавливаются события
        - `send_event_response(chat_id)` - выполнить функцию подготвоки и отправик сообщений
    - `elif text == "/help":` - иначе если содержимое переменной `text` равно строке `/help` отправить сообщение с текстом, какие есть команды и что они означают.
- `except Exception as e:` - обработка непредвиденной ошибки
    - `print(f"Ошибка: {e}")` - печать ошибки в консоль
- `return "Ok"` - возвращаемый `HTTP` ответ
---

```python
if __name__ == "__main__":
    public_url = sys.argv[1]
    result = set_webhook(public_url)
    print(result)
    app.run(host="0.0.0.0", port=5000, debug=True, use_reloader=False)
    print("Серрвер остановлен")
```
- `if __name__ == "__main__":` - точка входа для запуска приложения
- `public_url = sys.argv[1]` - запись переданного при запуске скрипта аргумента с адресом сервера по которому находится приложенеи
- `result = set_webhook(public_url)` - цепляем на этот адрес вебхук, чтобы ТГ сам слал нам сообщения если в чат бот что-то напишут
- `print(result)` - вывод результата установки вебхука в консоль
- `app.run(host="0.0.0.0", port=5000, debug=True, use_reloader=False)` - запуск приложения. веб-приложение будет запущено на всех доступных сетевых интерфейсах на порту 5000. Именованный аргумент `use_reloader=False` нужен только при разработке и отладке приложения, чтобы в планировщик при перезагрузке сервера не записывались новые экземпляры заданий. `debug=True` - включаем режим отладки. При изменении в коде и сохранении файла, сервер перезагрузится.
